# 元数据管理说明

## 📋 概述

本文档说明系统中元数据的管理机制，包括何时需要同步、何时不需要同步，以及最佳实践。

---

## 🔄 元数据同步时机

### ✅ **需要全量同步的场景**

以下情况需要调用 `syncMetadata()` 扫描所有文件并同步元数据：

#### 1. **系统启动时**（自动执行）
- **时机**：后端服务启动时
- **目的**：确保元数据与实际文件系统一致
- **操作**：扫描 `public/data` 目录下所有 TIF 文件，更新 `imageData.json`

#### 2. **用户点击"刷新"按钮**
- **时机**：用户在前端点击刷新按钮
- **目的**：清除缓存，重新扫描文件系统，获取最新状态
- **API**：`GET /api/image/list?refresh=true`
- **场景**：
  - 用户怀疑数据不一致
  - 外部修改了文件（如手动复制文件到 data 目录）
  - 需要强制更新列表

#### 3. **上传新文件后**（自动执行）
- **时机**：文件上传到服务器后
- **目的**：扫描新文件，创建元数据记录
- **流程**：
  1. 上传文件到 `public/data`
  2. 调用 `syncMetadata()` 扫描新文件
  3. **用户输入的元数据**覆盖从文件名解析的数据
  4. 保存到 `imageData.json`

#### 4. **优化文件完成后**（自动执行）
- **时机**：TIF 文件优化完成（投影转换、压缩、金字塔）
- **目的**：更新文件状态和大小信息
- **操作**：更新原记录或创建新记录（取决于是否覆盖原文件）

---

### ❌ **不需要全量同步的场景**（仅增量更新）

以下操作**只更新 `imageData.json` 中的记录**，不需要重新扫描所有文件：

#### 1. **编辑元数据**
- **操作**：用户修改年份、期次、区域、传感器等信息
- **API**：`PUT /api/image/:id`
- **实现**：
  ```javascript
  // 只更新指定记录的字段
  const image = metadata.images.find(img => img.id === id)
  image.year = updates.year
  image.period = updates.period
  writeMetadata(metadata)
  ```
- **原因**：只修改 JSON 数据，不涉及文件扫描

#### 2. **删除单个文件**
- **操作**：用户删除某个影像
- **API**：`DELETE /api/image/:id`
- **实现**：
  ```javascript
  // 1. 删除物理文件
  fs.unlinkSync(filePath)
  
  // 2. 从数组中移除记录
  metadata.images = metadata.images.filter(img => img.id !== id)
  writeMetadata(metadata)
  ```
- **原因**：直接从数组删除，无需扫描其他文件

#### 3. **批量删除文件**
- **操作**：用户批量删除多个影像
- **API**：`POST /api/image/batch-delete`
- **实现**：
  ```javascript
  // 1. 批量删除物理文件
  ids.forEach(id => fs.unlinkSync(filePath))
  
  // 2. 批量从数组中移除
  metadata.images = metadata.images.filter(img => !ids.includes(img.id))
  writeMetadata(metadata)
  ```
- **原因**：批量过滤数组，效率高，无需扫描

---

## 🚀 性能优化

### 1. **缓存机制**（5分钟）
- 获取影像列表时使用缓存，避免频繁扫描文件系统
- 缓存时长：5分钟
- 缓存清除时机：
  - 上传文件后
  - 删除文件后
  - 编辑元数据后
  - 用户点击刷新

```javascript
// 缓存逻辑
if (!forceRefresh && metadataCache && (now - lastSyncTime < CACHE_DURATION)) {
  return metadataCache  // 返回缓存
}
// 否则重新同步
```

### 2. **异步优化处理**
- 上传后立即返回响应
- 优化操作在后台异步执行
- 前端通过自动刷新检测完成状态

---

## 📊 元数据字段说明

### 核心字段

| 字段 | 类型 | 说明 | 来源 |
|------|------|------|------|
| `id` | String | 唯一标识（如 `IMG001`） | 自动生成 |
| `name` | String | 文件名（如 `2024_kle_vh_kndvi.tif`） | 文件系统 |
| `year` | String | 年份 | **用户输入** 或从文件名解析 |
| `period` | String | 期次（1-6） | **用户输入** 或默认值 |
| `cropType` | String | 作物类型 | **用户输入** 或默认 `all` |
| `region` | String | 区域代码 | **用户输入** 或从文件名解析 |
| `sensor` | String | 传感器类型 | **用户输入** 或从文件名解析 |
| `cloudCover` | Number | 云量（0-100） | **用户输入**（可选） |
| `size` | String | 文件大小（MB） | 文件系统自动读取 |
| `uploadTime` | String | 上传时间（ISO格式） | 文件修改时间 |
| `description` | String | 描述信息 | **用户输入**（可选） |

### 优化相关字段

| 字段 | 类型 | 说明 |
|------|------|------|
| `isOptimized` | Boolean | 是否已优化 |
| `isOptimizedResult` | Boolean | 是否为优化结果文件 |
| `originalSize` | String | 原始文件大小 |
| `optimizedSize` | String | 优化后文件大小 |
| `sourceFileId` | String | 源文件ID（优化结果文件） |

---

## 🔧 最佳实践

### 1. **上传文件时务必填写元数据**
用户在上传影像时应填写：
- 年份（必填）
- 期次（必填）
- 作物类型（必填）
- 区域、传感器（推荐）
- 云量、描述（可选）

> 💡 **原因**：这些信息会覆盖从文件名解析的数据，确保准确性

### 2. **定期检查数据一致性**
如果发现前端显示的数据不正确：
1. 点击"刷新"按钮，清除缓存
2. 检查后端日志，确认同步是否成功
3. 手动检查 `public/data/imageData.json` 文件

### 3. **不要直接修改 imageData.json**
- 所有元数据修改应通过前端界面或 API 完成
- 手动修改可能导致数据不一致
- 如果必须手动修改，修改后需点击"刷新"重新同步

---

## ⚠️ 常见问题

### Q1：为什么上传后显示的信息不是我输入的？

**原因**：旧版本后端没有从 `req.body` 中读取用户输入的元数据。

**解决方案**：已修复，现在上传时会优先使用用户输入的元数据。

---

### Q2：删除文件后是否需要手动同步？

**答案**：❌ 不需要。

删除操作已经自动更新了元数据，并清除了缓存。前端会在下次获取列表时自动刷新。

---

### Q3：什么时候需要点击"刷新"按钮？

**需要刷新的场景**：
- 外部工具直接复制/删除文件到 `public/data` 目录
- 怀疑数据不一致
- 长时间未操作，想获取最新状态

**不需要刷新的场景**：
- 通过前端上传、删除、编辑操作（自动同步）

---

### Q4：上传速度为什么很慢？

**原因**：
1. TIF 文件通常很大（几十 MB 到几 GB）
2. 网络带宽限制
3. 如果选择了优化，后台需要处理（但不影响上传响应）

**优化建议**：
- ✅ 现在会显示上传进度和预估时间
- ✅ 优化操作在后台异步执行，不阻塞上传
- 💡 使用有线网络或高速 WiFi
- 💡 批量上传时分批处理

---

## 📝 总结

### 元数据同步策略

```
┌─────────────────────────────────────────────────────────┐
│                   元数据同步决策树                        │
├─────────────────────────────────────────────────────────┤
│                                                           │
│  操作类型            是否需要全量同步    缓存清除          │
│  ────────────────────────────────────────────────────    │
│  系统启动            ✅ 是               N/A             │
│  用户点击刷新        ✅ 是               ✅ 是            │
│  上传文件            ✅ 是               ✅ 是            │
│  优化完成            ✅ 是               ✅ 是            │
│  编辑元数据          ❌ 否（增量更新）    ✅ 是            │
│  删除文件            ❌ 否（数组过滤）    ✅ 是            │
│  批量删除            ❌ 否（批量过滤）    ✅ 是            │
│  获取列表            ❌ 否（使用缓存）    ❌ 否            │
│                                                           │
└─────────────────────────────────────────────────────────┘
```

### 关键原则

1. **全量同步成本高**：只在必要时执行（启动、刷新、上传）
2. **增量更新优先**：删除、编辑操作只更新 JSON，不扫描文件
3. **缓存提升性能**：5分钟缓存，减少文件系统 I/O
4. **用户输入优先**：上传时用户填写的元数据优先级最高
5. **自动清除缓存**：任何修改操作后自动清除，确保一致性

---

## 🔗 相关文档

- [影像数据管理 API 文档](./README.md)
- [TIF 优化完整指南](./TIF优化完整指南.md)
- [部署指南](./DEPLOYMENT_GUIDE.md)

---

*最后更新：2025-10-27*

